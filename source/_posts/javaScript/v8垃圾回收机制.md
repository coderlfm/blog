---
title: v8垃圾回收机制
date: 2020-11-10 18:35:41
toc: true
tags:
cover: /cover-imgs/v8.png
---

v8 引擎中的内存分为 新生代内存 和 老生代内存
<!-- more -->

## 新生代内存
存活时间较短的对象被称为新生代内存
+ 新生代内存采用 `Scavenge算法` 来进行垃圾回收
    - Scavenge 算法是一种采用复制的方式实现的垃圾回收算法，`它会将新生代内存一分为二`, 只有一边是在使用的, 另外一边是空的, 使用的一边分为 from, 空的一边分为to
    - 当进行垃圾回收的时候，`会将 from 中存活的对象复制到 to 空间`，不存活的对象则将被释放，新生代内存整个垃圾回收机制就是对象的复制
    - 该算法是典型的利用空间换时间算法，无法进行大规模的垃圾回收机制，它比较适合新生代内存，因为新生代内存的生命周期较短
    - 当一个对象经历过多次复制之后，则会认为该对象是生命周期较长的对象，会将该对象添加到老生代内存，这个过程被称之为 `晋升`

    {% asset_img 图片3.png %}

<article class="message is-dark">
  <div class="message-header">
    <p>晋升的主要条件有两个</p>
    <!-- <button class="delete" aria-label="delete"></button> -->
  </div>
  <div class="message-body">
    如果该对象已经 `经历过内存回收`, 则会直接晋升到老生代内存<br/>
    如果 to 的空间使用 `超过了25%` , 则这个对象会直接晋升到老生代空间, 设置 25% 的原因是经历完这次回收后, `这个 to 空间会变成 from 空间`, 接下来的内存分配会在这个空间进行
  </div>
</article>

### 晋升的主要条件有两个
+ 如果该对象已经 `经历过内存回收`, 则会直接晋升到老生代内存
+ 如果 to 的空间使用 `超过了25%` , 则这个对象会直接晋升到老生代空间, 设置 25% 的原因是经历完这次回收后, `这个 to 空间会变成 from 空间`, 接下来的内存分配会在这个空间进行

----

## 老生代内存
存活时间长的内存被称为老生代内存
新生代内存采用 `mark-sweep 算法`和 `mark-compact 算法`配合来进行垃圾回收
 
+ mark-sweep 算法
    - mark-sweep 分为标记和清除两个阶段, mark-sweep会在标记阶段遍历堆中所有活着的对象, 在随后清除的阶段`只会清除未被标记的对象`, 因为在老生代内存中, 死亡的对象只占小部分, 这也是内存回收高效的原因, 
    - mark-sweep 还存在一个问题, 在进行完一次清除回收后, `会出现内存空间不连续的情况`, 如下图所示, 这就会对后续的内存分配出现很大的问题，这也是引入mark-compact的原因

    `灰色块为存活对象, 空白块为被清除后的内存空间`, 可以看到会出现内存空间不连续的情况
    {% asset_img 图片1.png %}


+ mark-compact 算法
    - mark-compact 会在一次标记清除后，进行一次标记整理, `它会把存活的对象往一端移动,`
    - 但是由于 mark-compact 会移动对象, 所有它的 `执行速度不会很快`, 老生代内存主要使用 mark-sweep, 如果有对象从新生代空间晋升来后内存不够需要进行空间分配时才会使用 mark-compact

    `标记整理后存活对象会往一端移动`
    {% asset_img 图片2old.png %}

所以对象的解除引用尽量使用重新赋值, 因为使用 delete 可能会干扰 v8 的垃圾回收优化
<!-- 
采用定时器需要动用红黑树，
创建定时器对象和迭代等操作, 而setTimeout(fn, 0)的方式较为浪费性能。实际上，
process.nextTick()方法的操作相对较为轻量 -->






