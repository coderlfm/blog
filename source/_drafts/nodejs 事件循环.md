---
title: nodejs 事件循环
date: 2022-05-21 22:36:27
tags:
cover: /cover-imgs/node-2.png
---

# nodejs 事件循环
<!-- more -->



*   孤儿进程

    父进程创建出一个子进程后，父进程关闭，子进程会被 root 进程 收养，这个子进程被称为 孤儿进程

*   僵尸进程

    父进程创建完一个子进程后，子进程已经退出，但是父进程没有wait



危害

孤儿进程的危害较小，父进程创建了子进程后，父进程已经关闭，那么它所创建的子进程被称为孤儿进程，会被 init (`pid` 为1)进程收养，然后循环的调用 `wait()`, 等待它的所有子进程结束后将其释放，init进程就类似于收养所，收养所有的孤儿，等到它去世后，党和政府负责善后



僵尸进程的生成在于父进程生成子进程后，子进程在`exit()`时，会释放它所占用的内存，打开过的文件描述符等，但是依旧会保留一些信息，例如进程号，退出状态，运行时间等，如果父进程不调用`wait()`而系统的进程号是有限的，如果产生了过多的僵尸进程，则系统可能会发生因为有过多的僵尸进程，导致无法分配出新的进程的情况

> c语言中通过调用`fork()` 可以开启一个子进程，子进程的`pid`是`0`，子进程可以通过调用exit() 向父进程发出退出信号，父进程通过调用`wait(&status)` 可以等待子进程关闭并获取退出时的状态

任何一个子进程在调用 `exit()` 后都不是消失掉，而是会先变成僵尸进程一段时间，然后等待父进程`wait() `后才会释放







![](https://box.kancloud.cn/2016-07-10_5781f6366022f.png)



## 事件循环的7个主要阶段

*   update\_time

*   timers

*   I/O callbacks

*   idle, prepare

*   I/O poll

*   check

*   close callbacks

也就是说，事件循环必须跑完这6个阶段，才算一个轮回。这一点一定要深刻记住。

## 1.update\_time

在事件循环的开头，这一步的作用实际上是为了获取一下系统时间，以保证之后的timer有个计时的标准。这个动作会在每次事件循环的时候都发生，确保了之后timer触发的准确性。（其实也不太准确....)

## 2. timers

事件循环跑到这个阶段的时候，要检查是否有`到期的timer`,其实也就是`setTimeout`和`setInterval`这种类型的timer，到期了，就会执行他们的回调。

## 3. I/O callbacks

处理异步事件的回调，比如网络I/O，比如文件读取I/O。当这些I/O动作都\*\**结束*\*\*的时候，在这个阶段会触发它们的回调。我特别指出了结束这个限定语。

## 4. idle, prepare

这个阶段内部做一些动作，与理解事件循环没啥关系

## 5. I/O poll阶段

这个阶段相当有意思，也是事件循环设计的一个有趣的点。这个阶段是\*\**选择运行*\*\*的。选择运行的意思就是不一定会运行。在这里，我先卖一个关子，后问详细深入讨论。

## 6. check

执行`setImmediate`操作

## 7. close callbacks

关闭I/O的动作，比如文件描述符的关闭，链接断开，等等等

